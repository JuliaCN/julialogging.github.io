var documenterSearchIndex = {"docs":
[{"location":"how-to/tee/#Send-messages-to-multiple-locations","page":"将消息发送到多个位置","title":"将消息发送到多个位置","text":"","category":"section"},{"location":"how-to/tee/","page":"将消息发送到多个位置","title":"将消息发送到多个位置","text":"在本教程中，我们将了解如何将日志消息同时发送到多个位置。在使用日志记录器和如何记录日志到文件中，我们看到了一些替代记录器（NullLogger，FileLogger, 等）以及如何使用它们。但是，在这些示例中，我们仅将消息发送到新记录器。LoggingExtras.jl 包为此目的实现了一个记录器TeeLogger。该名称的灵感来自 shell 工具 tee ，它将命令输出写入标准输出和文件。","category":"page"},{"location":"how-to/tee/","page":"将消息发送到多个位置","title":"将消息发送到多个位置","text":"一个非常常见的日志记录设置是将日志写入 stderr（如默认记录器所做的那样）和一个文件。以下是我们如何使用 TeeLogger、FileLogger和 默认的 ConsoleLogger来做到这点：","category":"page"},{"location":"how-to/tee/","page":"将消息发送到多个位置","title":"将消息发送到多个位置","text":"using Logging, LoggingExtras\n\nlogger = TeeLogger(\n    global_logger(),          # Current global logger (stderr)\n    FileLogger(\"logfile.log\") # FileLogger writing to logfile.log\n)\n\nnothing # hide","category":"page"},{"location":"how-to/tee/","page":"将消息发送到多个位置","title":"将消息发送到多个位置","text":"使用此记录器时，每条消息都将同时路由到默认记录器和文件。与日志消息过滤一起，可以创建任意日志消息路由，因为所有记录器都很好地组合并且可以嵌套。这在如何过滤消息中有更多描述，但下面给出了一个简短的例子。","category":"page"},{"location":"how-to/tee/","page":"将消息发送到多个位置","title":"将消息发送到多个位置","text":"这是一个将消息写入下面三个记录器的记录器：","category":"page"},{"location":"how-to/tee/","page":"将消息发送到多个位置","title":"将消息发送到多个位置","text":"默认的全局记录器（stderr），\nMinLevelLogger 接受级别 >= Info 的任何消息，并使用 FileLogger 将它们写入文件 \"logfile.log\"，\nMinLevelLogger 接受级别 >= Debug 的任何消息，并使用 FileLogger 将它们写入文件 \"debug.log\"。","category":"page"},{"location":"how-to/tee/","page":"将消息发送到多个位置","title":"将消息发送到多个位置","text":"using Logging, LoggingExtras\n\nlogger = TeeLogger(\n    # Current global logger (stderr)\n    global_logger(),\n    # Accept any messages with level >= Info\n    MinLevelLogger(\n        FileLogger(\"logfile.log\"),\n        Logging.Info\n    ),\n    # Accept any messages with level >= Debug\n    MinLevelLogger(\n        FileLogger(\"debug.log\"),\n        Logging.Debug,\n    ),\n)\n\nnothing # hide","category":"page"},{"location":"reference/logroller/#LogRoller.jl","page":"LogRoller.jl","title":"LogRoller.jl","text":"","category":"section"},{"location":"reference/logroller/","page":"LogRoller.jl","title":"LogRoller.jl","text":"Modules = [LogRoller]","category":"page"},{"location":"reference/logroller/#LogRoller.IndexedLogEntry","page":"LogRoller.jl","title":"LogRoller.IndexedLogEntry","text":"IndexedLogEntry represents a log entry as a dictionary and its indexable attributes in a form that is useful to a logging sink.\n\nThe index part contains metadata that are to be indexed. Event metadata consists of attributes like level, module, filepath, line, job id, process id, user id, etc. It also includes application specific keywords that the originating piece of code wishes to index.\n\nKeywords that should be considered as metadata are indicated via the indexable constructor parameter.\n\nWhat metadata can be indexed depends on the type of sink and whether it has support to index certain types of attributes. Attributes that the sink can not index are made part of the message itself for storage.\n\nThe message part can contain the following keys unless they are empty:\n\nmetadata: event metadata that could not be indexed\nmessage: the log message string\nkeywords: any keywords provided\n\nConstructor parameters:\n\nlog: Named tuple containing args to the handle_message method, e.g.: (level, message, _module, group, id, file, line, kwargs)\nindexable: list of names from log and log.kwargs that should be included in the index\n\n\n\n\n\n","category":"type"},{"location":"reference/logroller/#LogRoller.LogEntrySerialization","page":"LogRoller.jl","title":"LogRoller.LogEntrySerialization","text":"Custom JSON serializer for log entries. Handles Module types for now, more can be added later.\n\n\n\n\n\n","category":"type"},{"location":"reference/logroller/#LogRoller.RollingFileWriter","page":"LogRoller.jl","title":"LogRoller.RollingFileWriter","text":"A file writer that implements the IO interface, but only provides write methods.\n\nConstructor parameters:\n\nfilename: name (including path) of file to log into\nsizelimit: size of file (in bytes) after which the file should be rotated\nnfiles: number of rotated files to maintain\n\n\n\n\n\n","category":"type"},{"location":"reference/logroller/#LogRoller.RollingLogger","page":"LogRoller.jl","title":"LogRoller.RollingLogger","text":"RollingLogger(filename, sizelimit, nfiles, minlevel=Info; timestampidentifier::Symbol=:time, format::Symbol=:console) Log into a log file. Rotate log file based on file size. Compress rotated logs.\n\nLogs can be formatted as JSON by setting the optional keyword argument format to :json. A JSON formatted log entry is a JSON object. It should have these keys (unless they are empty): The message part can contain the following keys unless they are empty:\n\nmetadata: event metadata e.g. timestamp, line, filename, ...\nmessage: the log message string\nkeywords: any keywords provided\n\n\n\n\n\n","category":"type"},{"location":"reference/logroller/#Base.close-Tuple{LogRoller.RollingFileWriter}","page":"LogRoller.jl","title":"Base.close","text":"Close any open file handle and streams. A closed object must not be used again.\n\n\n\n\n\n","category":"method"},{"location":"reference/logroller/#Base.close-Tuple{LogRoller.RollingLogger}","page":"LogRoller.jl","title":"Base.close","text":"Close any open file handle and streams. A closed object must not be used again.\n\n\n\n\n\n","category":"method"},{"location":"reference/logroller/#Base.write-Tuple{LogRoller.RollingFileWriter, UInt8}","page":"LogRoller.jl","title":"Base.write","text":"Write into the underlying stream, rolling over as and when necessary.\n\n\n\n\n\n","category":"method"},{"location":"reference/logroller/#LogRoller.RollingFileWriterTee","page":"LogRoller.jl","title":"LogRoller.RollingFileWriterTee","text":"Tees raw log entries made a RollingFileWriter on to a provided Julia AbstractLogger.\n\nEach line of text is taken as a single log message.\n\nAll log entries are made with the same log level, which can be provided during construction. It leaves further examination/parsing of log messages (to extract parameters, or detect exact log levels) to the downstream logger.\n\n\n\n\n\n","category":"function"},{"location":"reference/logroller/#LogRoller.postrotate-Tuple{Function, LogRoller.RollingFileWriter}","page":"LogRoller.jl","title":"LogRoller.postrotate","text":"Register a function to be called with the rotated file name just after the current log file is rotated. The file name of the rotated file is passed as an argument. The function is blocking and so any lengthy operation that needs to be done should be done asynchronously.\n\n\n\n\n\n","category":"method"},{"location":"reference/logroller/#LogRoller.postrotate-Tuple{Function, LogRoller.RollingLogger}","page":"LogRoller.jl","title":"LogRoller.postrotate","text":"Register a function to be called with the rotated file name just after the current log file is rotated. The file name of the rotated file is passed as an argument. The function is blocking and so any lengthy operation that needs to be done should be done asynchronously.\n\n\n\n\n\n","category":"method"},{"location":"reference/logroller/#LogRoller.rotate_file-Tuple{LogRoller.RollingFileWriter}","page":"LogRoller.jl","title":"LogRoller.rotate_file","text":"Rotate files as below with increasing age:     - <filename> : active file     - <filename>1.gz : last rotated file     - <filename>2.gz : previous <filename>1.gz rotated to <filename>2.gz     - <filename>3.gz : previous <filename>2.gz rotated to <filename>3.gz     - ...     - <filename>n.gz : last rotated file is discarded when rotated\n\n\n\n\n\n","category":"method"},{"location":"reference/logroller/#LogRoller.tee-Tuple{LogRoller.RollingFileWriter, Base.CoreLogging.AbstractLogger, Base.CoreLogging.LogLevel}","page":"LogRoller.jl","title":"LogRoller.tee","text":"Tee all lines to the provided logger\n\n\n\n\n\n","category":"method"},{"location":"reference/sysloglogging/#SyslogLogging.jl","page":"SyslogLogging.jl","title":"SyslogLogging.jl","text":"","category":"section"},{"location":"reference/sysloglogging/","page":"SyslogLogging.jl","title":"SyslogLogging.jl","text":"Modules = [SyslogLogging]","category":"page"},{"location":"reference/sysloglogging/#SyslogLogging.SyslogLogger","page":"SyslogLogging.jl","title":"SyslogLogging.SyslogLogger","text":"Logs messages to a syslog facility.\n\n\n\n\n\n","category":"type"},{"location":"package-overview/#Logging—package-overview","page":"Logging 包概述","title":"Logging 包概述","text":"","category":"section"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"此章节包含 Julia 中和 logging 相关的一些包的概述。大部分的包和来自 Base 的标准 logging 前端宏 @debug，@info，@warn, @error 及 Logging.jl  标注库提供的抽象整合在一起。","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"note: Note\n如果一些 logging 相关的包不在下列列表中，不要犹豫，请立刻把它添加进来。 （译注：请至原文添加）。","category":"page"},{"location":"package-overview/#logging-overview","page":"Logging 包概述","title":"Logging.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"Logging 标准库提供了很多 logging 基础设施，大多数其他的 logging 包都建立在它的基础上。Logging 提供了global_logger 和 with_logger 来设置全局/局部（global/local）日志记录器，AbstractLogger 接口及以下三个记录器：","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"ConsoleLogger: Julia REPL 中的默认记录器\nSimpleLogger: ConsoleLogger 的基础版\nNullLogger: 等同于 /dev/null的记录器.","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"Logging 的功能被用于本文档中的大部分教程及 How-to。","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"详细信息请查看 Logging API reference。","category":"page"},{"location":"package-overview/#loggingextras-overview","page":"Logging 包概述","title":"LoggingExtras.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"LoggingExtras 包提供了一些 Logging 标准库的必要扩展。例如用于消息过滤的记录器： MinLevelLogger, EarlyFilteredLogger, ActiveFilteredLogger;用于任意消息转换的  TransformerLogger;用于消息路由的 TeeLogger; 以及三个不同的记录器槽:用于记录到磁盘文件的 FileLogger,用于自定义日志输出格式的 FormatLogger, 以及用于根据日期轮换记录到磁盘文件的 DatetimeRotatingFileLogger。","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"LoggingExtras 的功能被用于大部分的 How-to 指南，因此，请参考这些示例。","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"详细信息请查看 LoggingExtras API reference。","category":"page"},{"location":"package-overview/#loggingformats-overview","page":"Logging 包概述","title":"LoggingFormats.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"LoggingFormats 包提供了一些预定义的日志格式，用于和 LoggingExtras.jl 包中的 FormatLogger, DatetimeRotatingFileLogger 一起使用：","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"LoggingFormats.JSON: 输出序列化为 JSON 格式的日志消息。\nLoggingFormats.LogFmt: 输出格式化为 logfmt 格式的日志消息。\nLoggingFormats.Truncated: 类似 ConsoleLogger 的格式, 但是长消息会被截断。","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"详细信息请查看 LoggingFormats API reference。","category":"page"},{"location":"package-overview/#terminalloggers-overview","page":"Logging 包概述","title":"TerminalLoggers.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"TerminalLoggers 包提供了 TerminalLogger，它是更高级的的记录器，提供日志记录基于终端的漂亮输出。特别是它支持 Markdown 格式的日志消息，以及进度条（建立在 ProgressLogging 包之上）。","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"详细信息请查看 TerminalLoggers API reference。","category":"page"},{"location":"package-overview/#progresslogging-overview","page":"Logging 包概述","title":"ProgressLogging.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"ProgressLogging 包提供了一些很方便的前端宏，包括使跟踪循环结构进度的日志记录变得更简单的 @progress。","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"详细信息请查看 ProgressLogging API reference。","category":"page"},{"location":"package-overview/#logroller-overview","page":"Logging 包概述","title":"LogRoller.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"LogRoller 包提供了当日志文件达到大小限制时轮换日志文件的功能。特别是 IO RollingFileWriter (可以和其他的记录器组合使用) 以及 RollingLogger.","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"详细信息请查看 LogRoller API reference。","category":"page"},{"location":"package-overview/#logroller-overview-2","page":"Logging 包概述","title":"SyslogLogging.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"SyslogLogging 包提供了 SyslogLogger，它会把消息写到 syslog。","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"详细信息请查看 SyslogLogging API reference。","category":"page"},{"location":"package-overview/#logging2-overview","page":"Logging 包概述","title":"Logging2.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"Logging2 包提供了重定向 stdout 和 stderr 输出到日志系统的工具。","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"详细信息请查看 Logging2 API reference。","category":"page"},{"location":"package-overview/#tensorboardlogger-overview","page":"Logging 包概述","title":"TensorBoardLogger.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"TensorBoardLogger 包可以作为后端把结构化数值型数据记录到 TensorBoard。","category":"page"},{"location":"package-overview/#lokilogger-overview","page":"Logging 包概述","title":"LokiLogger.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"LokiLogger 包提供了 LokiLogger.Logger 记录器，它把日志消息通过 HTTP 发送到一个 Grafana Loki 服务器。","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"详细信息请查看 LokiLogger API reference。","category":"page"},{"location":"package-overview/#logcompose-overview","page":"Logging 包概述","title":"LogCompose.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"LogCompose 包提供了声明的记录器配置和相关的 .toml 文件格式。","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"详细信息请查看 LogCompose API reference。","category":"page"},{"location":"package-overview/#miniloggers-overview","page":"Logging 包概述","title":"MiniLoggers.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"MiniLoggers 包提供了 Julia 日志记录器的最小设置和简单而强大的日志字符串格式。它允许构建自定义的和紧凑的日志记录，支持色彩，输出到外部文件，时间戳等更多设置。","category":"page"},{"location":"package-overview/","page":"Logging 包概述","title":"Logging 包概述","text":"详细信息请查看 MiniLoggers API reference。","category":"page"},{"location":"how-to/rotate-log-files/#How-to-rotate-log-files","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"","category":"section"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"日志轮换对于长时间运行的应用程序很常见，例如网络服务器，请参见 logrotate 的 Linux 系统示例。日志轮换意味着根据某种标准替换日志文件。通常日志文件根据日期轮换，例如每天或每周，或根据文件大小轮换，例如将单个文件保持在 10MB 以下。","category":"page"},{"location":"how-to/rotate-log-files/#基于日期的日志轮换","page":"如何轮换日志文件","title":"基于日期的日志轮换","text":"","category":"section"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"LoggingExtras.jl 包实现了 DatetimeRotatingFileLogger，顾名思义，它是一个基于日期/时间的日志轮换记录器。日志轮换的频率是根据日期格式（请参阅 Dates.DateFormat 和 dateformat\"...\"）形式的输入文件名模式确定的。","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"让我们看一个初始示例：","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"using Logging, LoggingExtras\n\n# Directory for our log files\nlogdir = joinpath(@__DIR__, \"logs\")\nlogdir = joinpath(mktempdir(), \"logs\") # hide\nmkpath(logdir)\n\n# Filename pattern (see note below about character escaping)\nfilename_pattern = raw\"yyyy-mm-dd-\\w\\e\\b\\s\\e\\r\\v\\e\\r.\\l\\o\\g\"\n\n# Create the logger\nlogger = DatetimeRotatingFileLogger(logdir, filename_pattern)\n\nold_global_logger = global_logger() # hide\n# Install the logger globally\nglobal_logger(logger)\nglobal_logger(old_global_logger) # hide\nrm(logdir; recursive=true, force=true) # hide","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"这是一个每天轮换日志文件的记录器，因为“天”是文件名模式中最小的日期时间单位。","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"note: Note\n请注意，文件名模式中不属于日期时间模式的所有字符都将被转义。如果没有转义，这些字符也将被 Dates.DateFormat 解释。从技术上讲，并非所有字符都需要转义，例如 w 没有意义，但像上面的示例一样转义所有字符是最安全的。","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"经过几天的日志记录，我们会在日志目录中找到以下文件：","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"$ ls logs/\n2021-11-12-webserver.log\n2021-11-13-webserver.log\n2021-11-14-webserver.log\n2021-11-15-webserver.log","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"现在让我们通过添加两个 logrotate 中的常用的功能来改进记录器：文件压缩和文件保留策略。日志文件通常是可压缩的，添加压缩可以为我们节省一些空间。文件保留策略让我们将日志文件保留固定天数，例如 30 天，然后自动删除它们。对压缩和保留策略的支持不是内置的，但我们可以使用外部包来实现这些目的，并在回调函数中使用 rotation_callback 关键字参数实现此功能。DatetimeRotatingFileLogger 每次轮换日志文件时都会调用此函数。该函数的唯一参数是“旧”文件。","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"我们将通过 Gzip_jll 包使用 gzip 压缩，：","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"using Gzip_jll\n\nfunction logger_callback(file)\n    # Compress the file\n    Gzip_jll.gzip() do gzip\n        run(`$(gzip) $(file)`)\n    end\nend\nnothing # hide","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"对于文件保留策略，我们将使用 FilesystemDatastructures 包中的 NFileCache。这里我们创建了一个可以保存 30 个文件的文件缓存，：","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"using FilesystemDatastructures\n\n# Create a file cache that keeps 30 files\nfc = NFileCache(logdir, 30, DiscardLRU();\n                # Make sure only files ending with \"webserver.log.gz\" are included\n                predicate = x -> endswith(x, r\"webserver\\.log\\.gz\")\n)\nnothing # hide","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"现在我们只需要修改上面的回调，将轮换和压缩的文件添加到缓存中：","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"function logger_callback(file)\n    # Compress the file\n    Gzip_jll.gzip() do gzip\n        run(`$(gzip) $(file)`)\n    end\n    # Add the compressed file to the cache (gzip adds the .gz extension)\n    FilesystemDatastructures.add!(fc, file * \".gz\")\nend\nnothing # hide","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"当第 31 个文件添加到缓存中时，将自动删除最旧的文件来为新文件腾出空间。让应用程序运行一段时间后检查日志目录：","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"$ ls logs/\n2021-11-20-webserver.log.gz\n2021-11-21-webserver.log.gz\n2021-11-22-webserver.log.gz\n[...]\n2021-12-17-webserver.log.gz\n2021-12-18-webserver.log.gz\n2021-12-19-webserver.log.gz\n2021-12-20-webserver.log","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"30 个压缩文件，由缓存管理，还有一个“活动”文件尚未压缩并添加到缓存中。","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"这是完整示例：","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"using Logging, LoggingExtras, Gzip_jll, FilesystemDatastructures\n\n# Directory for our log files\nlogdir = joinpath(@__DIR__, \"logs\")\nlogdir = joinpath(mktempdir(), \"logs\") # hide\nmkpath(logdir)\n\n# Filename pattern\nfilename_pattern = raw\"yyyy-mm-dd-\\w\\e\\b\\s\\e\\r\\v\\e\\r.\\l\\o\\g\"\n\n# File cache that keeps 30 files\nfc = NFileCache(logdir, 30, DiscardLRU();\n                # Make sure only files ending with \"webserver.log.gz\" are included\n                predicate = x -> endswith(x, r\"webserver\\.log\\.gz\")\n)\n\n# Callback function for compression and adding to cache\nfunction logger_callback(file)\n    # Compress the file\n    Gzip_jll.gzip() do gzip\n        run(`$(gzip) $(file)`)\n    end\n    # Add the compressed file to the cache (gzip adds the .gz extension)\n    FilesystemDatastructures.add!(fc, file * \".gz\")\nend\n\n# Create the logger\nlogger = DatetimeRotatingFileLogger(\n             logdir, filename_pattern;\n             rotation_callback = logger_callback,\n)\n\nold_global_logger = global_logger() # hide\n# Install the logger globally\nglobal_logger(logger)\nglobal_logger(old_global_logger) # hide\nrm(logdir; recursive=true, force=true) # hide","category":"page"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"note: Note\n上面的设置与 Julia 的包服务器使用的日志记录设置非常相似，请参阅 JuliaPackaging/PkgServer.jl:bin/run_server.jl。","category":"page"},{"location":"how-to/rotate-log-files/#基于文件大小的日志轮换","page":"如何轮换日志文件","title":"基于文件大小的日志轮换","text":"","category":"section"},{"location":"how-to/rotate-log-files/","page":"如何轮换日志文件","title":"如何轮换日志文件","text":"对于基于文件大小的轮换，例如当文件大小达到特定阈值时进行文件轮换，请查看 LogRoller.jl 包。","category":"page"},{"location":"reference/logging2/#Logging2.jl","page":"Logging2.jl","title":"Logging2.jl","text":"","category":"section"},{"location":"reference/logging2/","page":"Logging2.jl","title":"Logging2.jl","text":"Modules = [Logging2]","category":"page"},{"location":"reference/logging2/#Logging2.LineBufferedIO","page":"Logging2.jl","title":"Logging2.LineBufferedIO","text":"LineBufferedIO(dest::IO)\n\nA thread safe line buffered IO wrapper which buffers writes until a full line (delimited by '\\n') is received. Full lines are written to the downstream dest IO.\n\nTo ensure that the tail of the stream is written (even without a trailing '\\n'), be sure to call close().\n\n\n\n\n\n","category":"type"},{"location":"reference/logging2/#Logging2.LoggingStream","page":"Logging2.jl","title":"Logging2.LoggingStream","text":"LoggingStream(logger; level, id)\n\nAn IO object which collects incoming calls to write and writes them to the Julia logging system via logger. Most useful when combined with LineBufferedIO. The standard logging _id field will be set to id.\n\n\n\n\n\n","category":"type"},{"location":"reference/logging2/#Base.redirect_stderr","page":"Logging2.jl","title":"Base.redirect_stderr","text":"redirect_stderr(f::Function, logger::AbstractLogger)\n\nRedirect the global stderr stream to logger, with each line becoming a log event during the execution of the function f.\n\nSee redirect_stdout for examples and additional information.\n\n\n\n\n\n","category":"function"},{"location":"reference/logging2/#Base.redirect_stdout","page":"Logging2.jl","title":"Base.redirect_stdout","text":"redirect_stdout(f::Function, logger::AbstractLogger)\n\nRedirect the global stdout stream to logger, with each line becoming a log event during the execution of the function f.\n\nnote: Note\nIn contrast to the dynamic scope of the usual logging system frontend (@info, etc), stdout is a global object so it's not entirely clear that we can collect the logger from the current dynamic scope where Base.stdout is looked up, and efficiently use it.In particular, some particular uses of stdout require it to have an operating system primitive like a Pipe backing the object. However not all uses require this, and it may be possible to improve the situation in the future.\n\nExamples\n\nHere's how you use redirect_stdout in structured concurrency style:\n\nredirect_stdout(current_logger()) do\n    println(\"Hi\")\n    run(`ls`)\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/terminalloggers/#TerminalLoggers.jl","page":"TerminalLoggers.jl","title":"TerminalLoggers.jl","text":"","category":"section"},{"location":"reference/terminalloggers/","page":"TerminalLoggers.jl","title":"TerminalLoggers.jl","text":"Modules = [TerminalLoggers]","category":"page"},{"location":"reference/terminalloggers/#TerminalLoggers.TerminalLoggers","page":"TerminalLoggers.jl","title":"TerminalLoggers.TerminalLoggers","text":"TerminalLoggers\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Codecov)\n\nTerminalLoggers provides a logger type TerminalLogger which can format your log messages in a richer way than the default ConsoleLogger which comes with the julia standard Logging library.\n\nRead the documentation for more information.\n\n\n\n\n\n","category":"module"},{"location":"reference/terminalloggers/#TerminalLoggers.StickyMessages","page":"TerminalLoggers.jl","title":"TerminalLoggers.StickyMessages","text":"StickyMessages(io::IO; ansi_codes=io isa Base.TTY && \n               (!Sys.iswindows() || VERSION >= v\"1.5.3\"))\n\nA StickyMessages type manages the display of a set of persistent \"sticky\" messages in a terminal. That is, messages which are not part of the normal scrolling output. Each message is identified by a label and may may be added to the set using push!(messages, label=>msg), and removed using pop!(messages, label), or empty!().\n\nOnly a single StickyMessages object should be associated with a given TTY, as the object manipulates the terminal scrolling region.\n\n\n\n\n\n","category":"type"},{"location":"reference/terminalloggers/#TerminalLoggers.TerminalLogger","page":"TerminalLoggers.jl","title":"TerminalLoggers.TerminalLogger","text":"TerminalLogger(stream=stderr, min_level=LogLevel(-1); meta_formatter=default_metafmt,\n               show_limited=true, right_justify=0)\n\nLogger with formatting optimized for interactive readability in a text console (for example, the Julia REPL). This is an enhanced version of the terminal logger Logging.ConsoleLogger which comes installed with Julia by default.\n\nLog levels less than min_level are filtered out.\n\nMessage formatting can be controlled by setting keyword arguments:\n\nmeta_formatter is a function which takes the log event metadata (level, _module, group, id, file, line) and returns a color (as would be passed to printstyled), prefix and suffix for the log message.  The default is to prefix with the log level and a suffix containing the module, file and line location.\nshow_limited limits the printing of large data structures to something which can fit on the screen by setting the :limit IOContext key during formatting.\nright_justify is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).\n\n\n\n\n\n","category":"type"},{"location":"tutorials/working-with-loggers/#Working-with-loggers","page":"使用日志记录器","title":"使用日志记录器","text":"","category":"section"},{"location":"tutorials/working-with-loggers/","page":"使用日志记录器","title":"使用日志记录器","text":"tip: Tip\n跟随教程把代码片段复制粘贴到 Julia REPL 中执行，是个不错的注意！","category":"page"},{"location":"tutorials/working-with-loggers/","page":"使用日志记录器","title":"使用日志记录器","text":"在这篇教程中，我们将学习如何使用记录器，例如接收和处理 @info 及其朋友们（查看 Logging 基本用法）发出的日志消息的后端。","category":"page"},{"location":"tutorials/working-with-loggers/","page":"使用日志记录器","title":"使用日志记录器","text":"Julia 中的默认记录器是 ConsoleLogger，它打印日志消息到终端（具体来说，它打印到 stderr）。","category":"page"},{"location":"tutorials/working-with-loggers/","page":"使用日志记录器","title":"使用日志记录器","text":"@info \"Hello default ConsoleLogger!\"","category":"page"},{"location":"tutorials/working-with-loggers/","page":"使用日志记录器","title":"使用日志记录器","text":"ConsoleLogger 只是记录器后端的其中一个实现，还有很多不同目的的其他实现，请查看 Logging 包概述。在此教程中，我们仅尝试 Logging.jl 标准库中定义的记录器，但是无论你使用那种记录器实现，使用记录器的函数都是相同的。","category":"page"},{"location":"tutorials/working-with-loggers/","page":"使用日志记录器","title":"使用日志记录器","text":"global_logger 函数用于获取或设置 全局记录器：","category":"page"},{"location":"tutorials/working-with-loggers/","page":"使用日志记录器","title":"使用日志记录器","text":"using Logging\nglobal_logger() = current_logger() # hide\nglobal_logger() |> typeof","category":"page"},{"location":"tutorials/working-with-loggers/","page":"使用日志记录器","title":"使用日志记录器","text":"当前的全局记录器会被任何衍生任务继承，因此，如果你想要为你的程序设置一个自定义的记录器，通常更新全局记录器就足够了。这里是一个如何设置全局记录器为 NullLogger 以禁言所有日志消息的示例：","category":"page"},{"location":"tutorials/working-with-loggers/","page":"使用日志记录器","title":"使用日志记录器","text":"using Logging\nlogger = NullLogger();\nold_logger = global_logger(logger); # save the old logger\nwith_logger(NullLogger()) do # hide\n@info \"This message goes to the new global NullLogger!\"\nend # hide\nglobal_logger(old_logger); # reset to the old logger\n@info \"This message goes to the old logger again!\"","category":"page"},{"location":"tutorials/working-with-loggers/","page":"使用日志记录器","title":"使用日志记录器","text":"正如你在此例中看到的，当设置一个新记录器时，global_logger 函数会返回旧记录器，然后我们重新设置全局记录器为旧记录器。对于一个程序/应用，这通常是你需要的一切–构造一个记录器或一个记录器组合，然后把它设置为全局记录器。","category":"page"},{"location":"tutorials/working-with-loggers/","page":"使用日志记录器","title":"使用日志记录器","text":"with_logger 函数可以为一个特定任务修改记录器。","category":"page"},{"location":"tutorials/working-with-loggers/","page":"使用日志记录器","title":"使用日志记录器","text":"using Logging\nlogger = NullLogger();\nwith_logger(logger) do\n    @info \"This message goes to the temporary logger!\"\nend\n@info \"Now the logger is back to normal.\"","category":"page"},{"location":"tutorials/working-with-loggers/","page":"使用日志记录器","title":"使用日志记录器","text":"如你所见，在调用 with_logger 之后，记录器的状态未改变，日志消息如之前一样打印。","category":"page"},{"location":"reference/logcompose/#LogCompose.jl","page":"LogCompose.jl","title":"LogCompose.jl","text":"","category":"section"},{"location":"reference/logcompose/","page":"LogCompose.jl","title":"LogCompose.jl","text":"Modules = [LogCompose]","category":"page"},{"location":"reference/logging/#Logging.jl","page":"Logging.jl","title":"Logging.jl","text":"","category":"section"},{"location":"reference/logging/#General-usage","page":"Logging.jl","title":"General usage","text":"","category":"section"},{"location":"reference/logging/","page":"Logging.jl","title":"Logging.jl","text":"Logging.@logmsg\nLogging.LogLevel\nLogging.Debug\nLogging.Info\nLogging.Warn\nLogging.Error\nLogging.global_logger\nLogging.current_logger\nLogging.with_logger\nLogging.ConsoleLogger\nLogging.SimpleLogger\nLogging.NullLogger","category":"page"},{"location":"reference/logging/#Logging.@logmsg","page":"Logging.jl","title":"Logging.@logmsg","text":"@debug message  [key=value | value ...]\n@info  message  [key=value | value ...]\n@warn  message  [key=value | value ...]\n@error message  [key=value | value ...]\n\n@logmsg level message [key=value | value ...]\n\nCreate a log record with an informational message.  For convenience, four logging macros @debug, @info, @warn and @error are defined which log at the standard severity levels Debug, Info, Warn and Error.  @logmsg allows level to be set programmatically to any LogLevel or custom log level types.\n\nmessage should be an expression which evaluates to a string which is a human readable description of the log event.  By convention, this string will be formatted as markdown when presented.\n\nThe optional list of key=value pairs supports arbitrary user defined metadata which will be passed through to the logging backend as part of the log record.  If only a value expression is supplied, a key representing the expression will be generated using Symbol. For example, x becomes x=x, and foo(10) becomes Symbol(\"foo(10)\")=foo(10).  For splatting a list of key value pairs, use the normal splatting syntax, @info \"blah\" kws....\n\nThere are some keys which allow automatically generated log data to be overridden:\n\n_module=mod can be used to specify a different originating module from the source location of the message.\n_group=symbol can be used to override the message group (this is normally derived from the base name of the source file).\n_id=symbol can be used to override the automatically generated unique message identifier.  This is useful if you need to very closely associate messages generated on different source lines.\n_file=string and _line=integer can be used to override the apparent source location of a log message.\n\nThere's also some key value pairs which have conventional meaning:\n\nmaxlog=integer should be used as a hint to the backend that the message should be displayed no more than maxlog times.\nexception=ex should be used to transport an exception with a log message, often used with @error. An associated backtrace bt may be attached using the tuple exception=(ex,bt).\n\nExamples\n\n@debug \"Verbose debugging information.  Invisible by default\"\n@info  \"An informational message\"\n@warn  \"Something was odd.  You should pay attention\"\n@error \"A non fatal error occurred\"\n\nx = 10\n@info \"Some variables attached to the message\" x a=42.0\n\n@debug begin\n    sA = sum(A)\n    \"sum(A) = $sA is an expensive operation, evaluated only when `shouldlog` returns true\"\nend\n\nfor i=1:10000\n    @info \"With the default backend, you will only see (i = $i) ten times\"  maxlog=10\n    @debug \"Algorithm1\" i progress=i/10000\nend\n\n\n\n\n\n","category":"macro"},{"location":"reference/logging/#Logging.LogLevel","page":"Logging.jl","title":"Logging.LogLevel","text":"LogLevel(level)\n\nSeverity/verbosity of a log record.\n\nThe log level provides a key against which potential log records may be filtered, before any other work is done to construct the log record data structure itself.\n\nExamples\n\njulia> Logging.LogLevel(0) == Logging.Info\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/logging/#Logging.Debug","page":"Logging.jl","title":"Logging.Debug","text":"Debug\n\nAlias for LogLevel(-1000).\n\n\n\n\n\n","category":"constant"},{"location":"reference/logging/#Logging.Info","page":"Logging.jl","title":"Logging.Info","text":"Info\n\nAlias for LogLevel(0).\n\n\n\n\n\n","category":"constant"},{"location":"reference/logging/#Logging.Warn","page":"Logging.jl","title":"Logging.Warn","text":"Warn\n\nAlias for LogLevel(1000).\n\n\n\n\n\n","category":"constant"},{"location":"reference/logging/#Logging.Error","page":"Logging.jl","title":"Logging.Error","text":"Error\n\nAlias for LogLevel(2000).\n\n\n\n\n\n","category":"constant"},{"location":"reference/logging/#Logging.global_logger","page":"Logging.jl","title":"Logging.global_logger","text":"global_logger()\n\nReturn the global logger, used to receive messages when no specific logger exists for the current task.\n\nglobal_logger(logger)\n\nSet the global logger to logger, and return the previous global logger.\n\n\n\n\n\n","category":"function"},{"location":"reference/logging/#Logging.current_logger","page":"Logging.jl","title":"Logging.current_logger","text":"current_logger()\n\nReturn the logger for the current task, or the global logger if none is attached to the task.\n\n\n\n\n\n","category":"function"},{"location":"reference/logging/#Logging.with_logger","page":"Logging.jl","title":"Logging.with_logger","text":"with_logger(function, logger)\n\nExecute function, directing all log messages to logger.\n\nExample\n\nfunction test(x)\n    @info \"x = $x\"\nend\n\nwith_logger(logger) do\n    test(1)\n    test([1,2])\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/logging/#Logging.ConsoleLogger","page":"Logging.jl","title":"Logging.ConsoleLogger","text":"ConsoleLogger([stream,] min_level=Info; meta_formatter=default_metafmt,\n              show_limited=true, right_justify=0)\n\nLogger with formatting optimized for readability in a text console, for example interactive work with the Julia REPL.\n\nLog levels less than min_level are filtered out.\n\nMessage formatting can be controlled by setting keyword arguments:\n\nmeta_formatter is a function which takes the log event metadata (level, _module, group, id, file, line) and returns a color (as would be passed to printstyled), prefix and suffix for the log message.  The default is to prefix with the log level and a suffix containing the module, file and line location.\nshow_limited limits the printing of large data structures to something which can fit on the screen by setting the :limit IOContext key during formatting.\nright_justify is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).\n\n\n\n\n\n","category":"type"},{"location":"reference/logging/#Logging.SimpleLogger","page":"Logging.jl","title":"Logging.SimpleLogger","text":"SimpleLogger([stream,] min_level=Info)\n\nSimplistic logger for logging all messages with level greater than or equal to min_level to stream. If stream is closed then messages with log level greater or equal to Warn will be logged to stderr and below to stdout.\n\n\n\n\n\n","category":"type"},{"location":"reference/logging/#Logging.NullLogger","page":"Logging.jl","title":"Logging.NullLogger","text":"NullLogger()\n\nLogger which disables all messages and produces no output - the logger equivalent of /dev/null.\n\n\n\n\n\n","category":"type"},{"location":"reference/logging/#Logging-interface","page":"Logging.jl","title":"Logging interface","text":"","category":"section"},{"location":"reference/logging/","page":"Logging.jl","title":"Logging.jl","text":"Logging.AbstractLogger\nLogging.min_enabled_level\nLogging.shouldlog\nLogging.catch_exceptions\nLogging.handle_message","category":"page"},{"location":"reference/logging/#Logging.AbstractLogger","page":"Logging.jl","title":"Logging.AbstractLogger","text":"A logger controls how log records are filtered and dispatched.  When a log record is generated, the logger is the first piece of user configurable code which gets to inspect the record and decide what to do with it.\n\n\n\n\n\n","category":"type"},{"location":"reference/logging/#Logging.min_enabled_level","page":"Logging.jl","title":"Logging.min_enabled_level","text":"min_enabled_level(logger)\n\nReturn the minimum enabled level for logger for early filtering.  That is, the log level below or equal to which all messages are filtered.\n\n\n\n\n\n","category":"function"},{"location":"reference/logging/#Logging.shouldlog","page":"Logging.jl","title":"Logging.shouldlog","text":"shouldlog(logger, level, _module, group, id)\n\nReturn true when logger accepts a message at level, generated for _module, group and with unique log identifier id.\n\n\n\n\n\n","category":"function"},{"location":"reference/logging/#Logging.catch_exceptions","page":"Logging.jl","title":"Logging.catch_exceptions","text":"catch_exceptions(logger)\n\nReturn true if the logger should catch exceptions which happen during log record construction.  By default, messages are caught\n\nBy default all exceptions are caught to prevent log message generation from crashing the program.  This lets users confidently toggle little-used functionality - such as debug logging - in a production system.\n\nIf you want to use logging as an audit trail you should disable this for your logger type.\n\n\n\n\n\n","category":"function"},{"location":"reference/logging/#Logging.handle_message","page":"Logging.jl","title":"Logging.handle_message","text":"handle_message(logger, level, message, _module, group, id, file, line; key1=val1, ...)\n\nLog a message to logger at level.  The logical location at which the message was generated is given by module _module and group; the source location by file and line. id is an arbitrary unique value (typically a Symbol) to be used as a key to identify the log statement when filtering.\n\n\n\n\n\n","category":"function"},{"location":"how-to/filter-messages/#How-to-filter-messages","page":"如何过滤消息","title":"如何过滤消息","text":"","category":"section"},{"location":"how-to/filter-messages/","page":"如何过滤消息","title":"如何过滤消息","text":"在此教程中，我们将看到如何基于元数据（level, module等）和日志消息内容来过滤消息。在如何启用 @debug 消息和 发送消息到多个位置中有如何基于日志级别过滤消息的示例。","category":"page"},{"location":"how-to/filter-messages/","page":"如何过滤消息","title":"如何过滤消息","text":"在日志系统消息管道中，可以分两个阶段过滤消息。在第一阶段，只有元数据是已知的（level, module, group, 和 id）。特别是消息字符串本身尚未构建，如果创建日志消息的成本很高，则在此阶段进行过滤可能会更有效。例如，在","category":"page"},{"location":"how-to/filter-messages/","page":"如何过滤消息","title":"如何过滤消息","text":"@info \"The value of some_expensive_call is: $(some_expensive_call(args...))\"","category":"page"},{"location":"how-to/filter-messages/","page":"如何过滤消息","title":"如何过滤消息","text":"中，在早期阶段还未发生对 some_expensive_call 的调用。当有更多信息可用时，例如完整的消息字符串、文件和行以及任何关键字参数，消息也可以稍后过滤。","category":"page"},{"location":"how-to/filter-messages/#早期过滤使用-EarlyFilteredLogger","page":"如何过滤消息","title":"早期过滤使用 EarlyFilteredLogger","text":"","category":"section"},{"location":"how-to/filter-messages/","page":"如何过滤消息","title":"如何过滤消息","text":"可以使用 LoggingExtras.jl 包中的 EarlyFilteredLogger 来完成早期阶段的过滤。EarlyFilteredLogger 需要一个谓词函数和一个记录器作为输入参数。如果谓词返回 true，则消息被传递给包装的记录器，否则被忽略。谓词函数的唯一输入是一个命名元组，请参阅 LoggingExtras.shouldlog_args。","category":"page"},{"location":"how-to/filter-messages/","page":"如何过滤消息","title":"如何过滤消息","text":"这是一个记录器的示例，它只接受 (i)Logging.Info 级别（Logging.Info <= level < Logging.Warn）的消息和 (ii) 来自 Foo 模块的消息：","category":"page"},{"location":"how-to/filter-messages/","page":"如何过滤消息","title":"如何过滤消息","text":"using Logging, LoggingExtras\n\n# Define the Foo module\nmodule Foo\n    info() = @info \"Information from Foo\"\n    warn() = @warn \"Warning from Foo\"\nend\nusing .Foo\n\nbegin # hide\n# Create the logger\nglobal_logger() = current_logger() # hide\nlogger = EarlyFilteredLogger(global_logger()) do args\n    r = Logging.Info <= args.level < Logging.Warn && args._module === Foo\n    return r\nend\n\n# Test it\nwith_logger(logger) do\n    @info \"Information from Main\"\n    @warn \"Warning from Main\"\n    Foo.info()\n    Foo.warn()\nend\nend # hide","category":"page"},{"location":"how-to/filter-messages/","page":"如何过滤消息","title":"如何过滤消息","text":"如您所见，唯一没有被过滤器丢弃的是来自 Foo 模块的 @info 消息！","category":"page"},{"location":"how-to/filter-messages/","page":"如何过滤消息","title":"如何过滤消息","text":"note: Note\nMinLevelLogger 只是 EarlyFilteredLogger 的一个特例，它只检查消息的日志级别是否高于配置的级别。","category":"page"},{"location":"how-to/filter-messages/","page":"如何过滤消息","title":"如何过滤消息","text":"和 TeeLogger 一起，我们现在可以为消息创建任意路由。这是一个更复杂的例子：","category":"page"},{"location":"how-to/filter-messages/","page":"如何过滤消息","title":"如何过滤消息","text":"using Logging, LoggingExtras\n\nmodule WebServer end # hide\nlogger = TeeLogger(\n    global_logger(),\n    EarlyFilteredLogger(\n        args -> args._module === WebServer,\n        TeeLogger(\n            EarlyFilteredLogger(\n                args -> args.level < Logging.Info,\n                FileLogger(\"debug.log\"),\n            ),\n            EarlyFilteredLogger(\n                args -> Logging.Info <= args.level < Logging.Warn,\n                FileLogger(\"info.log\"),\n            ),\n            EarlyFilteredLogger(\n                args -> Logging.Warn <= args.level,\n                FileLogger(\"warnings_and_errors.log\"),\n            ),\n        )\n    ),\n)\nnothing # hide","category":"page"},{"location":"how-to/filter-messages/","page":"如何过滤消息","title":"如何过滤消息","text":"此记录器将所有消息发送到当前的全局记录器和 EarlyFilteredLogger. 然后 EarlyFilteredLogger 丢弃所有不是来自 WebServer 模块的消息，并将剩余的消息发送到新的 TeeLogger. 此TeeLogger 会将消息发送到三个 EarlyFilteredLoggers，它们只保留特定级别的消息并将这些消息发送到对应于该级别的 FileLogger。这意味着，\"debug.log\" 只有来自 WebServer（第一个过滤器）并且具有 debug 日志级别的消息。类似地， \"info.log\" 中只会有 info 日志级别的消息，任何更高级别（warn, error）的消息都将位于 \"warnings_and_errors.log\" 中。","category":"page"},{"location":"how-to/filter-messages/#后期过滤使用-ActiveFilteredLogger","page":"如何过滤消息","title":"后期过滤使用 ActiveFilteredLogger","text":"","category":"section"},{"location":"how-to/filter-messages/","page":"如何过滤消息","title":"如何过滤消息","text":"如果基于级别、模块、组和 id 的过滤不够，可以使用 ActiveFilteredLogger，它也来自 LoggingExtras.jl 包。此记录器类似于 EarlyFilteredLogger，唯一的区别是传给谓词函数的命名元组包含更多数据，请参阅 LoggingExtras.handle_message_args。以下是根据消息字符串内容进行过滤的记录器示例：","category":"page"},{"location":"how-to/filter-messages/","page":"如何过滤消息","title":"如何过滤消息","text":"using Logging, LoggingExtras\n\nbegin # hide\nglobal_logger() = current_logger() # hide\nlogger = ActiveFilteredLogger(global_logger()) do args\n    return args.message == \"Hello there!\" || args.message == \"General Kenobi!\"\nend\n\nwith_logger(logger) do\n    @info \"I find your lack of faith disturbing.\"\n    @info \"Hello there!\"\n    @info \"General Kenobi!\"\n    @info \"Power! Unlimited power!\"\nend\nend # hide","category":"page"},{"location":"reference/loggingformats/#LoggingFormats.jl","page":"LoggingFormats.jl","title":"LoggingFormats.jl","text":"","category":"section"},{"location":"reference/loggingformats/","page":"LoggingFormats.jl","title":"LoggingFormats.jl","text":"LoggingFormats.JSON\nLoggingFormats.LogFmt\nLoggingFormats.Truncated","category":"page"},{"location":"reference/loggingformats/#LoggingFormats.JSON","page":"LoggingFormats.jl","title":"LoggingFormats.JSON","text":"JSON\n\nSerialize log messages as JSON.\n\n\n\n\n\n","category":"type"},{"location":"reference/loggingformats/#LoggingFormats.LogFmt","page":"LoggingFormats.jl","title":"LoggingFormats.LogFmt","text":"LogFmt\n\nFormat log messages as logfmt.\n\n\n\n\n\n","category":"type"},{"location":"reference/loggingformats/#LoggingFormats.Truncated","page":"LoggingFormats.jl","title":"LoggingFormats.Truncated","text":"Truncated\n\nFormat log messages similar to ConsoleLogger, but truncate long messages.\n\n\n\n\n\n","category":"type"},{"location":"how-to/enable-debug/#How-to-enable-debug-messages","page":"如何启用 @debug 消息","title":"如何启用 @debug 消息","text":"","category":"section"},{"location":"how-to/enable-debug/","page":"如何启用 @debug 消息","title":"如何启用 @debug 消息","text":"默认 debug 级日志消息默认是不可见的。这是因为默认的 ConsoleLogger 接收的最低日志级别是 Logging.Info – 任何比它低的都将被丢弃。","category":"page"},{"location":"how-to/enable-debug/","page":"如何启用 @debug 消息","title":"如何启用 @debug 消息","text":"启用所有 @debug 级消息的最简单方式是，创建一个接收所有消息的新记录器。示例如下：","category":"page"},{"location":"how-to/enable-debug/","page":"如何启用 @debug 消息","title":"如何启用 @debug 消息","text":"using Logging\n\n# New ConsoleLogger that prints to stderr and accept messages with level >= Logging.Debug\ndebug_logger = ConsoleLogger(stderr, Logging.Debug)\nnothing # hide","category":"page"},{"location":"how-to/enable-debug/","page":"如何启用 @debug 消息","title":"如何启用 @debug 消息","text":"新的记录器现在可以用于替代任务的本地记录器或全局记录器，请参考使用日志记录器。示例如下：","category":"page"},{"location":"how-to/enable-debug/","page":"如何启用 @debug 消息","title":"如何启用 @debug 消息","text":"begin # hide\ndebug_logger = ConsoleLogger(stderr, Logging.Debug) # hide\nwith_logger(debug_logger) do # Enable the debug logger locally\n     @debug \"This is visible now!\"\nend\nend # hide\n\nbegin # hide\nold_global_logger = global_logger() # hide\ndebug_logger = ConsoleLogger(stderr, Logging.Debug) # hide\nglobal_logger(debug_logger); # Enable the debug logger globally\nglobal_logger(old_global_logger) # hide\nend # hide\nwith_logger(ConsoleLogger(stderr, Logging.Debug)) do # hide\n@debug \"This is visible now!\"\nend # hide","category":"page"},{"location":"how-to/enable-debug/","page":"如何启用 @debug 消息","title":"如何启用 @debug 消息","text":"此方法适用于任何接收日志级别作为参数的日志记录器，然而，情况并非总是如此。启用 debug 消息的另一个更具组合性的选择是，使用基于日志级别的消息过滤，如何过滤消息章节是这种方法的更详细描述，但是这里给出的日志级别过滤示例使用了 MinLevelLogger。","category":"page"},{"location":"how-to/enable-debug/","page":"如何启用 @debug 消息","title":"如何启用 @debug 消息","text":"MinLevelLogger 记录器是另一个记录器的封装，但是只让足够高级别的消息传入给被封装的记录器。这个示例中，我们封装了一个接收每个消息级别（Logging.BelowMinLevel）的 ConsoleLogger。","category":"page"},{"location":"how-to/enable-debug/","page":"如何启用 @debug 消息","title":"如何启用 @debug 消息","text":"using Logging, LoggingExtras\n\nbegin # hide\nlogger = MinLevelLogger(\n    ConsoleLogger(stderr, Logging.BelowMinLevel),\n    Logging.Debug,\n)\n\nwith_logger(logger) do\n    @debug \"This is visible!\"\nend\nend # hide","category":"page"},{"location":"how-to/enable-debug/","page":"如何启用 @debug 消息","title":"如何启用 @debug 消息","text":"要选择性地启用来自某些模块或包的调试消息，或基于日志级别等事情进行过滤，请查看如何过滤消息章节。 To selectively enable debug messages from e.g. certain modules or packages, or filtering based on things other than the log level, see How to filter messages.","category":"page"},{"location":"how-to/enable-debug/#JULIA_DEBUG-环境变量","page":"如何启用 @debug 消息","title":"JULIA_DEBUG 环境变量","text":"","category":"section"},{"location":"how-to/enable-debug/","page":"如何启用 @debug 消息","title":"如何启用 @debug 消息","text":"另一个“快速又随性”地启用 debug 消息的方式是，使用JULIA_DEBUG (请查看 Logging/Environmental variables)环境变量。此变量可以设置为 all 以启用所有调试消息，或设置为一个或多个以逗号分隔的模块名列表来选择性启用某些模块的调试消息。然而，使用 JULIA_DEBUG 组合的并不像使用适当的日志消息过滤那样好（请查看如何过滤消息）。请查看此问题的示例以获取更多讨论和信息： JuliaLogging/LoggingExtras.jl#20。","category":"page"},{"location":"reference/miniloggers/#MiniLoggers.jl","page":"MiniLoggers.jl","title":"MiniLoggers.jl","text":"","category":"section"},{"location":"reference/miniloggers/","page":"MiniLoggers.jl","title":"MiniLoggers.jl","text":"Modules = [MiniLoggers]","category":"page"},{"location":"reference/miniloggers/#MiniLoggers.MiniLogger-Tuple{}","page":"MiniLoggers.jl","title":"MiniLoggers.MiniLogger","text":"MiniLogger(; <keyword arguments>)\n\nMiniLogger constructor creates custom logger which can be used with usual @info, @debug commands.\n\nSupported keyword arguments include:\n\nio (default stdout): IO stream which is used to output log messages below errlevel level. Can be either IO or String, in the latter case it is treated as a name of the output file.\nioerr (default stderr): IO stream which is used to output log messages above errlevel level. Can be either IO or String, in the latter case it is treated as a name of the output file.\nerrlevel (default Error): determines which output IO to use for log messages. If you want for all messages to go to io, set this parameter to MiniLoggers.AboveMaxLevel. If you want for all messages to go to ioerr, set this parameter to MiniLoggers.BelowMinLevel.\nminlevel (default: Info): messages below this level are ignored. For example with default setting @debug \"foo\" is ignored.\nappend (default: false): defines whether to append to output stream or to truncate file initially. Used only if io or ioerr is a file path.\nmessage_mode (default: :squash): choose how message is transformed before being printed out. Following modes are supported:\n:notransformations: message printed out as is, without any extra transformations\n:squash: message is squashed to a single line, i.e. all \\n are changed to squash_delimiter and \\r are removed.\n:fullsquash: all messages including error stacktraces are squashed to a single line, i.e. all \\n are changed to squash_delimiter and \\r are removed\n:markdown: message is treated as if it is written in markdown\nsquash_delimiter: (default: \"\\t\"): defines which delimiter to use in squash mode.\nflush (default: true): whether to flush IO stream for each log message. Flush behaviour also affected by flush_threshold argument.\nflush_threshold::Union{Integer, TimePeriod} (default: 0): if this argument is nonzero and flush is true, then io is flushed only once per flush_threshold milliseconds. I.e. if time between two consecutive log messages is less then flush_threshold, then second message is not flushed and will have to wait for the next log event.\ndtformat (default: \"yyyy-mm-dd HH:MM:SS\"): if datetime parameter is used in format argument, this dateformat is applied for output timestamps.\nformat (default: \"[{timestamp:func}] {level:func}: {message}\"): format for output log message. It accepts following keywords, which should be provided in curly brackets:\ntimestamp: timestamp of the log message\nlevel: name of log level (Debug, Info, etc)\nfilepath: filepath of the file, which produced log message\nbasename: basename of the filepath of the file, which produced log message\nline: line number of the log command in the file, which produced log message\ngroup: log group \nmodule: name of the module, which contains log command\nid: log message id\nmessage: message itself\n\nEach keyword accepts color information, which should be added after colon inside curly brackets. Colors can be either from Base.text_colors or special keyword func, in which case is used automated coloring. Additionaly, bold modifier is accepted by the format argument. For example: {line:red}, {module:cyan:bold}, {group:func} are all valid parts of the format command.\n\nColour information is applied recursively without override, so {{line} {module:cyan} {group}:red} is equivalent to {line:red} {module:cyan} {group:red}.\n\nIf part of the format is not a recognised keyword, then it is just used as is, for example {foo:red} means that output log message contain word \"foo\" printed in red.\n\n\n\n\n\n","category":"method"},{"location":"reference/progresslogging/#ProgressLogging.jl","page":"ProgressLogging.jl","title":"ProgressLogging.jl","text":"","category":"section"},{"location":"reference/progresslogging/","page":"ProgressLogging.jl","title":"ProgressLogging.jl","text":"Modules = [ProgressLogging]","category":"page"},{"location":"reference/progresslogging/#ProgressLogging.ProgressLogging","page":"ProgressLogging.jl","title":"ProgressLogging.ProgressLogging","text":"ProgressLogging: a package for defining progress logs\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Codecov) (Image: Coveralls)\n\nProgressLogging.jl is a package for defining progress logs.  It can be used to report progress of a loop/loops with time-consuming body:\n\njulia> using ProgressLogging\n\njulia> @progress for i in 1:10\n           sleep(0.1)\n       end\n\nThis package does not contain any progress monitors for visualizing the progress of the program.  You need to install a package supporting progress logs created by ProgressLogging.jl API.  For example:\n\nJuno\nTerminalLoggers.jl\n\n\n\n\n\n","category":"module"},{"location":"reference/progresslogging/#ProgressLogging.ROOTID","page":"ProgressLogging.jl","title":"ProgressLogging.ROOTID","text":"ProgressLogging.ROOTID\n\nThis is used as parentid of root Progresses.\n\n\n\n\n\n","category":"constant"},{"location":"reference/progresslogging/#ProgressLogging.Progress","page":"ProgressLogging.jl","title":"ProgressLogging.Progress","text":"ProgressLogging.Progress(id, [fraction]; [parentid, name, done])\n\nUsage: Progress log record provider\n\nProgress log record can be created by using the following pattern\n\nid = uuid4()\ntry\n    @info Progress(id)  # create a progress bar\n    # some time consuming job\n    # ...\n    @info Progress(id, 0.1)  # update progress to 10%\n    # ...\nfinally\n    @info Progress(id, done = true)  # close the progress bar\nend\n\nIt is recommended to use @withprogress, @logprogress, and optionally @progressid to create log records.\n\nUsage: Progress log record consumer (aka progress monitor)\n\nIt is recommended to use ProgressLogging.asprogress instead of checking message isa Progress.  Progress monitors can retrieve progress-related information from the following properties.\n\nProperties\n\nfraction::Union{Float64,Nothing}: it can take following values:\n0 <= fraction < 1\nfraction >= 1: completed\nfraction = nothing: indeterminate progress\nid::UUID: Identifier of the job whose progress is at fraction.\nparentid::UUID: The ID of the parent progress.  It is set to ProgressLogging.ROOTID when there is no parent progress. This is used for representing progresses of nested jobs.  Note that sub-jobs may be executed concurrently; i.e., there can be multiple child jobs for one parent job.\nname::String: Name of the progress bar.\ndone::Bool: true if the job is done.\n\n\n\n\n\n","category":"type"},{"location":"reference/progresslogging/#ProgressLogging.asprogress-Tuple{Any, ProgressLogging.Progress, Vararg{Any}}","page":"ProgressLogging.jl","title":"ProgressLogging.asprogress","text":"ProgressLogging.asprogress(_, name, _, _, id, _, _; progress, ...) :: Union{Progress, Nothing}\n\nPre-process log record to obtain a Progress object if it is one of the supported format.  This is mean to be used with the message positional argument and all keyword arguments passed to Logging.handle_message.  Example:\n\nfunction Logging.handle_message(logger::MyLogger, args...; kwargs...)\n    progress = ProgressLogging.asprogress(args...; kwargs...)\n    if progress !== nothing\n        return # handle progress log record\n    end\n    # handle normal log record\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/progresslogging/#ProgressLogging.progress-Tuple{Any}","page":"ProgressLogging.jl","title":"ProgressLogging.progress","text":"progress(f::Function; name = \"\")\n\nEvaluates f with id as its argument and makes sure to destroy the progress bar afterwards. To update the progress bar in f you can call a logging statement like @info or even just @logmsg with _id=id and progress as arguments.\n\nprogress can take either of the following values:\n\n0 <= progress < 1: create or update progress bar\nprogress == nothing || progress = NaN: set progress bar to indeterminate progress\nprogress >= 1 || progress == \"done\": destroy progress bar\n\nThe logging message (e.g. \"foo\" in @info \"foo\") will be used as the progress bar's name.\n\nLog level must be higher or equal to LogLevel(-1).\n\nProgressLogging.progress() do id\n    for i = 1:10\n        sleep(0.5)\n        @info \"iterating\" progress=i/10 _id=id\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/progresslogging/#ProgressLogging.@logprogress","page":"ProgressLogging.jl","title":"ProgressLogging.@logprogress","text":"@logprogress [name] progress [key1=val1 [key2=val2 ...]]\n\nThis macro must be used inside @withprogress macro.\n\nLog a progress event with a value progress.  The expression progress must be evaluated to be a real number between 0 and 1 (inclusive), a NaN, or a string \"done\".\n\nOptional first argument name can be used to change the name of the progress bar.  Additional keyword arguments are passed to @logmsg.\n\n\n\n\n\n","category":"macro"},{"location":"reference/progresslogging/#ProgressLogging.@progress-Tuple","page":"ProgressLogging.jl","title":"ProgressLogging.@progress","text":"@progress [name=\"\", threshold=0.005] for i = ..., j = ..., ...\n@progress [name=\"\", threshold=0.005] x = [... for i = ..., j = ..., ...]\n\nShow a progress meter named name for the given loop or array comprehension if possible. Update frequency is limited by threshold (one update per 0.5% of progress by default).\n\n\n\n\n\n","category":"macro"},{"location":"reference/progresslogging/#ProgressLogging.@progressid-Tuple{}","page":"ProgressLogging.jl","title":"ProgressLogging.@progressid","text":"@progressid\n\nGet the progress ID of current lexical scope.\n\n\n\n\n\n","category":"macro"},{"location":"reference/progresslogging/#ProgressLogging.@withprogress-Tuple","page":"ProgressLogging.jl","title":"ProgressLogging.@withprogress","text":"@withprogress [name=\"\"] [parentid=uuid4()] ex\n\nCreate a lexical environment in which @logprogress can be used to emit progress log events without manually specifying the log level, _id, and name (log message).\n\n@withprogress name=\"iterating\" begin\n    for i = 1:10\n        sleep(0.5)\n        @logprogress i/10\n    end\nend\n\n\n\n\n\n","category":"macro"},{"location":"reference/loggingextras/#LoggingExtras.jl","page":"LoggingExtras.jl","title":"LoggingExtras.jl","text":"","category":"section"},{"location":"reference/loggingextras/","page":"LoggingExtras.jl","title":"LoggingExtras.jl","text":"Modules = [LoggingExtras]","category":"page"},{"location":"reference/loggingextras/#LoggingExtras.ActiveFilteredLogger","page":"LoggingExtras.jl","title":"LoggingExtras.ActiveFilteredLogger","text":"ActiveFilteredLogger(filter, logger)\n\nWraps logger in an active filter. While loggers intrinsictally have in built filtering mechanisms. Wrapping it in a ActiveFilterLogger allows for extract control, at the cost of a bit of overhead.\n\nThe ActiveFilteredLogger has full control of what is logged, as it sees the full message, this does mean however it determines what to log at runtime, which is the source of the overhead. The EarlyFilteredLogger has less control, but decides if to log before the message is computed.\n\nThe filter should be a function that returns a boolean. true if the message should be logged and false if not. As input it will be given a named tuple with the following fields: (level, message, _module, group, id, file, line, kwargs) See LoggingExtras.handle_message_args for more information on what each is.\n\n\n\n\n\n","category":"type"},{"location":"reference/loggingextras/#LoggingExtras.DatetimeRotatingFileLogger","page":"LoggingExtras.jl","title":"LoggingExtras.DatetimeRotatingFileLogger","text":"DatetimeRotatingFileLogger(dir, file_pattern; always_flush=true, rotation_callback=identity)\nDatetimeRotatingFileLogger(f::Function, dir, file_pattern; always_flush=true, rotation_callback=identity)\n\nConstruct a DatetimeRotatingFileLogger that rotates its file based on the current date. The constructor takes a log output directory, dir, and a filename pattern. The smallest time resolution in the format string determines the frequency of log file rotation, allowing for yearly all the way down to minute-level log rotation.\n\nThe pattern can be given as a string or as a Dates.DateFormat. Note that if you wish to have a filename portion that should not be interpreted as a format string, you may need to escape portions of the filename, as shown in the example below.\n\nIt is possible to pass a formatter function as the first argument to control the output. The formatting function should be of the form f(io::IOContext, log_args::NamedTuple) where log_args has the following fields: (level, message, _module, group, id, file, line, kwargs). See LoggingExtras.handle_message_args for more information about what each field represents.\n\nIt is also possible to pass rotation_callback::Function as a keyword argument. This function will be called every time a file rotation is happening. The function should accept one argument which is the absolute path to the just-rotated file. The logger will block until the callback function returns. Use @async if the callback is expensive.\n\nExamples\n\n# Logger that logs to a new file every day\nlogger = DatetimeRotatingFileLogger(log_dir, raw\"\\a\\c\\c\\e\\s\\s-yyyy-mm-dd.\\l\\o\\g\")\n\n# Logger with a formatter function that rotates the log file hourly\nlogger = DatetimeRotatingFileLogger(log_dir, raw\"yyyy-mm-dd-HH.\\l\\o\\g\") do io, args\n    println(io, args.level, \" | \", args.message)\nend\n\n# Example callback function to compress the recently-closed file\ncompressor(file) = run(`gzip $(file)`)\nlogger = DatetimeRotatingFileLogger(...; rotation_callback=compressor)\n\n\n\n\n\n","category":"type"},{"location":"reference/loggingextras/#LoggingExtras.EarlyFilteredLogger","page":"LoggingExtras.jl","title":"LoggingExtras.EarlyFilteredLogger","text":"EarlyFilteredLogger(filter, logger)\n\nWraps logger in an filter that runs before the log message is created.\n\nFor contrast see the ActiveFilteredLogger which has full control, but runs after the log message content is computed. In most circumstances this is fine, but if your log messages are expensive to create (e.g. they include summary statistics), then the EarlyFilteredLogger is going to be better.\n\nThe filter should be a function that returns a boolean. true if the message should be logged and false if not. As input it will be given a named tuple with the following fields: (level, _module, group, id) See LoggingExtras.shouldlog_args for more information on what each is.\n\n\n\n\n\n","category":"type"},{"location":"reference/loggingextras/#LoggingExtras.FileLogger-Tuple{Any}","page":"LoggingExtras.jl","title":"LoggingExtras.FileLogger","text":"FileLogger(path::AbstractString; append=false, always_flush=true)\n\nCreate a logger sink that write messages to a file specified with path. To append to the file (rather than truncating the file first), use append=true. If always_flush=true the stream is flushed after every handled log message.\n\n\n\n\n\n","category":"method"},{"location":"reference/loggingextras/#LoggingExtras.FileLogger-Tuple{IOStream}","page":"LoggingExtras.jl","title":"LoggingExtras.FileLogger","text":"FileLogger(io::IOStream; always_flush=true)\n\nCreate a logger sink that write messages to the io::IOStream. The stream is expected to be open and writeable. If always_flush=true the stream is flushed after every handled log message.\n\nExamples\n\nio = open(\"path/to/file.log\", \"a\") # append to the file\nlogger = FileLogger(io)\n\n\n\n\n\n","category":"method"},{"location":"reference/loggingextras/#LoggingExtras.FormatLogger","page":"LoggingExtras.jl","title":"LoggingExtras.FormatLogger","text":"FormatLogger(f::Function, io::IO=stderr; always_flush=true)\n\nLogger sink that formats the message and finally writes to io. The formatting function should be of the form f(io::IOContext, log_args::NamedTuple) where log_args has the following fields: (level, message, _module, group, id, file, line, kwargs). See LoggingExtras.handle_message_args for more information on what field is.\n\nExamples\n\njulia> using Logging, LoggingExtras\n\njulia> logger = FormatLogger() do io, args\n           println(io, args._module, \" | \", \"[\", args.level, \"] \", args.message)\n       end;\n\njulia> with_logger(logger) do\n           @info \"This is an informational message.\"\n           @warn \"This is a warning, should take a look.\"\n       end\nMain | [Info] This is an informational message.\nMain | [Warn] This is a warning, should take a look.\n\n\n\n\n\n","category":"type"},{"location":"reference/loggingextras/#LoggingExtras.MinLevelLogger","page":"LoggingExtras.jl","title":"LoggingExtras.MinLevelLogger","text":"MinLevelLogger(logger, min_enabled_level)\n\nWraps logger in an filter that runs before the log message is created. In many ways this is just a specialised EarlyFilteredLogger that only checks the level. This filter only allowed messages on or above the min_enabled_level to pass.\n\n\n\n\n\n","category":"type"},{"location":"reference/loggingextras/#LoggingExtras.TeeLogger-Tuple{Vararg{Base.CoreLogging.AbstractLogger}}","page":"LoggingExtras.jl","title":"LoggingExtras.TeeLogger","text":"TeeLogger(loggers...)\n\nSend the same log message to all the loggers.\n\nTo include the current logger do: TeeLogger(current_logger(), loggers...) to include the global logger, do: TeeLogger(global_logger(), loggers...)\n\n\n\n\n\n","category":"method"},{"location":"reference/loggingextras/#LoggingExtras.TransformerLogger","page":"LoggingExtras.jl","title":"LoggingExtras.TransformerLogger","text":"TransformerLogger(f, logger)\n\nPreprocesses log messages, using the function f, before passing them to the logger that is wrapped. This can be used, for example, to truncate a log message. to conditionally change the log level of logs from a given module (which depending on the wrappped logger, might cause the message to be dropped).\n\nThe transforming function f is given a named tuple with the fields: (level, message, _module, group, id, file, line, kwargs) and should return the same. See LoggingExtras.handle_message_args for more information on what each is.\n\n\n\n\n\n","category":"type"},{"location":"reference/loggingextras/#LoggingExtras.handle_message_args-Tuple","page":"LoggingExtras.jl","title":"LoggingExtras.handle_message_args","text":"handle_message_args\n\nThis creates NamedTuple containing all the arguments the logger gives to handle_message It is the type pased to the active logger filter. These argument come from the logging macro (@info,@warn` etc).\n\nlevel::LogLevel Warn, Info, etc,\nmessage::String the message to be logged\n_module::Module can be used to specify a different originating module from the source location of the message.\ngroup::Symbol can be used to override the message group (this is normally derived from the base name of the source file).\nid::Symbol can be used to override the automatically generated unique message identifier.  This is useful if you need to very closely associate messages generated on different source lines.\nfile::String and line::Int can be used to override the apparent source location of a log message.\nkwargs...: Any  keyword or position arguments passed to the logging macro\n\n\n\n\n\n","category":"method"},{"location":"reference/loggingextras/#LoggingExtras.next_datetime_transition-Tuple{Dates.DateFormat}","page":"LoggingExtras.jl","title":"LoggingExtras.next_datetime_transition","text":"next_datetime_transition(fmt::DateFormat)\n\nGiven a DateFormat that is being applied to our filename, what is the next time at which our filepath will need to change?\n\n\n\n\n\n","category":"method"},{"location":"reference/loggingextras/#LoggingExtras.shouldlog_args-Tuple","page":"LoggingExtras.jl","title":"LoggingExtras.shouldlog_args","text":"shouldlog_args\n\nThis returns a NamedTuple containing all the arguments the logger gives to shouldlog It is passed to the early logger filter. These argument come from the logging macro (@info, @warn etc).\n\nlevel::LogLevel Warn, Info, etc,\n_module::Module can be used to specify a different originating module from the source location of the message.\ngroup::Symbol can be used to override the message group (this is normally derived from the base name of the source file).\nid::Symbol can be used to override the automatically generated unique message identifier.  This is useful if you need to very closely associate messages generated on different source lines.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/logging-basics/#Logging-basics","page":"Logging 基本用法","title":"Logging 基本用法","text":"","category":"section"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"在此教程中，我们将学习发出日志消息和日志事件的基本用法。我们也会学习一点关于每条 log 消息由哪些信息组成以及当 log 消息发出后发生了什么。如果你要写一个脚本或者包，此章节应该覆盖了你需要的所有信息。","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"tip: Tip\n跟随教程把代码片段复制粘贴到 Julia REPL 中执行，是个不错的注意！","category":"page"},{"location":"tutorials/logging-basics/#基本日志事件","page":"Logging 基本用法","title":"基本日志事件","text":"","category":"section"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"log 事件中大部分重要的信息是日志消息和日志级别。日志消息通常是一个信息量很大的文本字符串，日志级别是个严重性级别，用来向读者说明 log 消息的重要性。Julia的 Base 模块默认是可用的，它提供了日志宏 @ingo, @warn, @error,和 @debug 来创建日志消息。它们对应到常见的日志级别：","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"Info: 有用的信息但是一点也不严重\nWarning: 一些某事可能不正确的信息\nError: 某事发生了错误的信息\nDebug: 在调试时很有用的附加信息","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"让我们看看如何使用上面提到的宏创建一些日志消息：","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"@info \"This is an info message, carry on as usual.\"\n@warn \"This is a warning message, something might be wrong?\"\n@error \"This is an error message, something is not working as it should!\"\n@debug \"This is a debug message, it is invisible!\"\nprintstyled(\"\\njulia>\"; color=:green, bold=true) # hide","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"正如你看到的，简单的用法只需要宏，它确定了日志级别和消息字符串。默认的日志后端负责处理我们生成的日志消息，像上面示例展示的一样打印已格式化，色彩化的消息到终端。格式默认是由日志级别决定的： @info 消息不输出像 @warn 和 @error 一样的位置信息（模块，文件，行号）。你也可以注意到 @debug 消息默认情况下是关闭的。通常在你调试代码中的问题需要更多信息时，才需要开启它们。","category":"page"},{"location":"tutorials/logging-basics/#向日志事件添加额外元数据","page":"Logging 基本用法","title":"向日志事件添加额外元数据","text":"","category":"section"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"在上述示例中，我们传给日志宏的唯一信息是日志消息字符串。可以通过在消息字符串后面附加额外事物来传递更多信息。额外信息可以使用 key = value 语法添加：","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"@info \"hello, world\" x = [1, 2, 3] y = \"something else\"","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"或者仅附加一个变量:","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"x = [3, 4, 5];\n@info \"hello, world\" x","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"在这两个示例中，你可以看打日志后端很好的格式化了日志消息字符串后面的额外信息。添加额外信息在一些情况下是很有用的，特别是如果你想保持消息字符串不变，只传递一些动态信息。","category":"page"},{"location":"tutorials/logging-basics/#日志级别","page":"Logging 基本用法","title":"日志级别","text":"","category":"section"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"四个日志级别 Info, Warn, Error, 和 Debug 只是特定数字级别的别名，允许的日志级别范围正如你在下表看到的：","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"Level Alias Comment\n-1000001 Logging.BelowMinLevel (below) lowest possible level\n-1000 Logging.Debug log level for @debug messages\n0 Logging.Info log level for @info messages\n1000 Logging.Warn log level for @warn messages\n2000 Logging.Error log level for @error messages\n1000001 Logging.AboveMaxLevel (above) highest possible level","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"Logging 模块是 Julia 自带的，提供了 @logmsg 宏，它是目前为止提到的其他宏的泛化。使用此宏时除了消息字符串，它还要求传递一个日志级别，但除此之外，@logmsg 的工作原理是一样的，这是一些示例：","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"using Logging\n@logmsg Logging.Info \"Info message from @logmsg.\"\n@logmsg Logging.Error \"Error message from @logmsg.\" x = [1, 2, 3]","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"@logmsg 宏也可以使用 LogLevel 构造函数创建任何级别的日志消息：","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"@logmsg Logging.LogLevel(123) \"Log message with log level 123.\"\n@logmsg Logging.LogLevel(1234) \"Log message with log level 1234.\"\n@logmsg Logging.LogLevel(2345) \"Log message with log level 2345.\"","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"从彩色输出我们可以推断出日志级别 123 是一个 info 消息，日志级别 1234 是一个 Warn 消息，日志级别 2345 是一个 Error 消息。你也可以在上表的帮助下看到这些：一个具有等级 X 的日志消息是一个：","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"debug message if Logging.Debug <= X < Logging.Info,\ninfo message if Logging.Info <= X < Logging.Warn,\nwarn message if Logging.Warn <= X < Logging.Error,\nerror message if Logging.Error <= X < Logging.AboveMaxLevel.","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"像这样自定义的日志级别不常见，但是有时它很方便，并且具有一些更细粒度的控制。","category":"page"},{"location":"tutorials/logging-basics/#位置元数据","page":"Logging 基本用法","title":"位置元数据","text":"","category":"section"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"在上面的日志输出中你看到一些其他元数据附加到消息。特别是，日志事件的来源模块，文件名和行号被打印。因为代码是在 Julia REPL 中运行的，模块是 Main，文件是 REPL[..]，行号为 1。每个上面提到的宏生成的日志事件都和以下元数据关联：","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"来源模块，\n来源文件，\n来源行号，\n一个日志事件 id（位置独有的），\n一个日志事件组（默认为文件名）。","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"由日志后端选择如何处理此信息。例如，Julia REPL 中默认的记录器后端对于 @info 消息不显式元数据，对于其他消息仅显式模块，文件，和行号。也可以覆盖默认设置，例如改变来源位置。你需要传递关键字参数到日志消息宏来做到：","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"@warn \"Overriding the source module\" _module = Base\n@warn \"Overriding the source file\" _file = \"example.jl\"\n@warn \"Overriding the source line\" _line = 123\n@warn \"Overriding the log event group\" _group = :example\n@warn \"Overriding the log event id\" _id = :id","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging 基本用法","title":"Logging 基本用法","text":"因此默认的记录器后端仅显式模块，文件，和行号，其他的覆盖是不可见的。","category":"page"},{"location":"reference/lokilogger/#LokiLogger.jl","page":"LokiLogger.jl","title":"LokiLogger.jl","text":"","category":"section"},{"location":"reference/lokilogger/","page":"LokiLogger.jl","title":"LokiLogger.jl","text":"Modules = [LokiLogger]","category":"page"},{"location":"reference/lokilogger/#LokiLogger.Logger","page":"LokiLogger.jl","title":"LokiLogger.Logger","text":"LokiLogger.Logger(server::Union{String,URI}; labels::Dict)\nLokiLogger.Logger(fmt::Function, server::Union{String,URI}; labels::Dict)\n\nCreate a logger that send messages to a Loki server.\n\nThe log messages are attributed with the labels given in the labels dictionary. If no labels are specified the default labels are:\n\n\"host\" => gethostname()\n\"app\"  => \"LokiLogger.jl\"\n\nThe fmt argument is used for formatting. There are two builtin formatting functions:\n\nLokiLogger.logfmt (default): formats the log message in the logfmt format,\nLokiLogger.json: formats the log message as JSON.\n\nCustom functions must take two arguments: an io::IO to write the message to, and args::NamedTuple that contains all the logger arguments, see help for LoggingExtras.handle_message_args for details.\n\nExamples\n\n# Create a logger with a single label and default (logfmt) formatting\nlogger = LokiLogger.Logger(\"http://localhost:3100\"; labels = Dict(\"app\" => \"myapp\"))\n\n# Create a logger with json output formatting\nlogger = LokiLogger.Logger(LokiLogger.json, \"http://localhost:3100\")\n\n# Create a logger with custom formatting\nlogger = LokiLogger.Logger(\"http://localhost:3100\") do io, args\n    # Only output the level and the message\n    print(io, args.level, \": \", args.message)\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/lokilogger/#LokiLogger.json-Tuple{IO, Any}","page":"LokiLogger.jl","title":"LokiLogger.json","text":"json(io::IO, args)\n\nFormat the log message as JSON and write to io.\n\nExample logline:\n\n{\"level\":\"info\",\"msg\":\"hello, world\",\"module\":\"Main\",\"file\":\"/run.jl\",\"line\":2,\"group\":\"run\",\"id\":\"Main_6972c827\"}\n\n\n\n\n\n","category":"method"},{"location":"reference/lokilogger/#LokiLogger.logfmt-Tuple{IO, Any}","page":"LokiLogger.jl","title":"LokiLogger.logfmt","text":"logfmt(io::IO, args)\n\nFormat the log message in logfmt key-value format and print to io.\n\nExample logline:\n\nlevel=info msg=\"hello, world\" module=Main file=\"/run.jl\" line=2 group=run id=Main_6972c827\n\n\n\n\n\n","category":"method"},{"location":"#欢迎来到-JuliaLogging!","page":"Home","title":"欢迎来到 JuliaLogging!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"这是 JuliaLogging GitHub 组织的主页。 JuliaLogging 是Julia 编程语言生态系统中和 logging 相关的软件包及源码库的一个伞状组织。","category":"page"},{"location":"","page":"Home","title":"Home","text":"此文档的目标是成为 Julia 中和 logging 相关的任何事的“一站式商店”。此文档按照如下结构组织[1]：","category":"page"},{"location":"","page":"Home","title":"Home","text":"教程 将会教你 Julia logging 系统的基本用法。\nHow-to 指南 将会指导你完成常见任务和用例所涉及的步骤。这比教程更高级，并且假设你已具备 Julia logging 系统的一些知识。\n参考 包含函数和 API 的技术参考（例如 docstrings）。在查找详细信息时使用此参考。\n背景和讨论 涵盖一些高级主题。","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\n请帮助改善此文档 – 如果什么东西使你感到困惑，有可能不止你一个人。阅读时很容易做到：只需点击每个页面顶部的 “Edit on Github” 链接，然后直接在你的浏览器中编辑文件。你的修改在成为正式文档之前将会被开发人员审查，因此无需担心会说错什么。 （译注：请至原文编辑）。","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: 文档的组织遵从 Diátaxis 框架。","category":"page"},{"location":"how-to/log-to-file/#How-to-log-to-a-file","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"","category":"section"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"tip: Tip\n跟随教程把代码片段复制粘贴到 Julia REPL 中执行，是个不错的注意！","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"通常需要把日志消息发送到日志文件，而不是记录到终端。来自 Logging 标准库的 ConsoleLogger 和 SimpleLogger 接收一个 IO 流作为输入，因此，在这些记录器中插入一个文件流并记录到文件是很简单的。这是一个示例：","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"using Logging\n\nio = open(\"logfile.txt\", \"w\")\nlogger = ConsoleLogger(io)\n\nwith_logger(logger) do\n    @info \"Message to the logfile\"\nend\n\nclose(io)","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"当读取文件并打印结果时，我们可以验证此文件包含预期的日志输入：","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"print(read(\"logfile.txt\", String))\nrm(\"logfile.txt\") # hide","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"使用这种方法，您可能会注意到，由于 IO buffering，消息将延迟写入文件，或者可能直到程序结束和文件关闭时才写入。此外，像上面的例子那样自己管理文件 IO 流有点烦人。由于这些原因，通常最好使用专门为文件写入而实现的记录器。","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"LoggingExtras.jl包提供了 FileLogger, 顾名思义，这是专门为将消息写入文件而实现的。FileLogger 打开文件并在处理每条消息后自动刷新流。以下是 FileLogger 的使用示例：","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"using Logging, LoggingExtras\n\nlogger = FileLogger(\"logfile.txt\")\n\nwith_logger(logger) do\n    @info \"First message to the FileLogger!\"\nend","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"读取和打印内容：","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"print(read(\"logfile.txt\", String))","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"默认情况下，当 FileLogger 打开文件流时，使用 “write” 模式（请参阅文档 open），这意味着如果文件存在并且有一些内容，它将被覆盖。可以通过传递 append = true 给构造函数来使用“追加”模式。这将保留文件中的内容并且仅在末尾追加。这是一个示例，打开和上面相同的文件，但使用 append = true：","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"\nlogger = FileLogger(\"logfile.txt\"; append = true)\n\nwith_logger(logger) do\n    @info \"Second message to the FileLogger?\"\nend\n\nprint(read(\"logfile.txt\", String))\nrm(\"logfile.txt\") # hide","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"如您所见，第一条消息仍在文件中，我们只附加了第二条。","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"在 FileLogger 内部使用了 SimpleLogger，因此输出格式与SimpleLogger。 如果你想控制输出格式，你可以使用FormatLogger（也来自 LoggingExtras.jl）代替。FormatLogger 接受一个格式化函数作为第一个参数。格式化函数有两个参数：(i) 写入格式化消息的 IO 流和 (ii) 日志参数（参见 LoggingExtras.handle_message_args）。这是一个例子：","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"using Logging, LoggingExtras\n\nlogger = FormatLogger(open(\"logfile.txt\", \"w\")) do io, args\n    # Write the module, level and message only\n    println(io, args._module, \" | \", \"[\", args.level, \"] \", args.message)\nend\n\nwith_logger(logger) do\n    @info \"Info message to the FormatLogger!\"\n    @warn \"Warning message to the FormatLogger!\"\nend\n\nprint(read(\"logfile.txt\", String))\nrm(\"logfile.txt\") # hide","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"FormatLogger 需要我们使用推荐选项（\"w\", \"a\", 等）手动打开文件流，就像 FileLogger 一样，它会在每条消息后刷新流。","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"也可以看看：","category":"page"},{"location":"how-to/log-to-file/","page":"如何记录日志到文件","title":"如何记录日志到文件","text":"将消息发送到多个位置，了解如何将日志消息发送到多个记录器，例如发送到文件和终端。\n如何轮换日志文件 获取更多文件日志记录选项。","category":"page"},{"location":"tutorials/implement-a-new-logger/#实现一个新的日志记录器","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"","category":"section"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"在此教程中，我们将会经历实现一个新记录器的必需步骤。这包括定义一个新的结构体，它是 Logging.AbstractLogger 的子类型，并且为此记录器接口实现必需的方法。","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"note: Note\n通常，除非你要实现一个新的记录器槽（logger sink)，否则不需要定义新的记录器来获取你想要的行为。LoggingExtras.jl 包提供了任意路由，转换，和过滤日志事件的记录器。例如，在此示例中实现的记录器使用 TransformerLogger 实现起来很简单（请参阅本页的最后一部分）。","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"作为一个玩具示例，我们将实现一个加密记录器–一个使用 Caesar cipher） 来“加密”消息的记录器。我们想要记录器接收任何日志事件，并且可以使用输出流进行配置。开始吧！","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"tip: Tip\n跟随教程把代码片段复制粘贴到 Julia REPL 中执行，是个不错的注意！","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"第一步是加载 Logging.jl 标准库，它定义了记录日志的基础设置和必须方法，我们需要为新记录器进行扩展。然后我们定义新记录器的结构，确保使用 Logging.AbstractLogger 作为超类（supertype)：","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"using Logging\n\nstruct CipherLogger <: Logging.AbstractLogger\n    io::IO\n    key::Int\nend\n\nCipherLogger(key::Int=3) = CipherLogger(stderr, key)","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"输入到记录器结构的是 I/O 流和凯撒密码的密钥，所有的日志消息都会被写入此流，密钥只是一个整数。一个供外部使用的方便结构也会定义一些默认值：I/O 流默认为 stderr，密钥默认为 3。","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"下一步，我们需要为新的 CipherLogger 扩展必需的方法：","category":"page"},{"location":"tutorials/implement-a-new-logger/#[Logging.min_enabled_level](@ref)","page":"实现一个新的日志记录器","title":"Logging.min_enabled_level","text":"","category":"section"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"此方法应该返回日志记录器接收消息的最小等级。Julia REPL 中默认记录器只接收 Logging.Info 及以上级别的消息，例如，我们想要我们的记录器接收任何消息,因此我们简单的返回 Logging.BelowMinLevel，这是最小的合理级别：","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"Logging.min_enabled_level(logger::CipherLogger) = Logging.BelowMinLevel","category":"page"},{"location":"tutorials/implement-a-new-logger/#[Logging.shouldlog](@ref)","page":"实现一个新的日志记录器","title":"Logging.shouldlog","text":"","category":"section"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"此方法是过滤日志消息的下一个机会。输入参数是记录器，日志消息级别，被创建日志事件的所属模块，和唯一标识事件创建位置的日志事件 id。基于此信息，我们可以决定记录器是否应该接收消息并返回 true，或者它应该丢弃消息并返回 false。再一次，因为我们想让我们的记录器接收任何消息，无论输入参数是什么，我们都简单的返回 true： ","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"function Logging.shouldlog(logger::CipherLogger, level, _module, group, id)\n   return true\nend","category":"page"},{"location":"tutorials/implement-a-new-logger/#[Logging.catch_exceptions](@ref)","page":"实现一个新的日志记录器","title":"Logging.catch_exceptions","text":"","category":"section"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"此方法决定我们的记录器是否应该捕获来自日志记录系统的异常。这是可以做到的，例如，当生成日志消息时发生的异常。如果 catch_exceptions 返回 true，日志记录系统将发送一个 error 日志消息到记录器，否则不发送。让我们接收这些 error 日志消息：","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"Logging.catch_exceptions(logger::CipherLogger) = true","category":"page"},{"location":"tutorials/implement-a-new-logger/#[Logging.handle_message](@ref)","page":"实现一个新的日志记录器","title":"Logging.handle_message","text":"","category":"section"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"此方法是日志事件最终到达的位置。输入参数是记录器，日志级别，消息，和关于消息来源位置的元数据（module, group, id, file, 和 line）。另外，日志事件可能有关键字参数，例如：","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"@info \"hello, world\" time = time()","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"记录器将会发送关键字参数 time => time()（详细信息请查看 Logging 基本用法教程）。基于此信息，我们现在将为我们的记录器生成一个日志消息，把它打印到记录器 I/O 流。当然，一般来说此方法不必写入常规流，它可以把日志事件发送为一个 HTTP 请求（和 LokiLogger.jl 类似），或者作为短信发送到你的手机。我们 CipherLogger 的 handle_message 函数是非常简单的：我们把消息加密，然后输出级别和加密后的消息：","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"function Logging.handle_message(logger::CipherLogger,\n                                lvl, msg, _mod, group, id, file, line;\n                                kwargs...)\n    # Apply Ceasar cipher on the log message\n    msg = caesar(msg, logger.key)\n    # Write the formatted log message to logger.io\n    println(logger.io, \"[\", lvl, \"] \", msg)\nend","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"现在唯一缺失的部分是 caesar 函数，它应该用记录器的密钥加密消息。这里的加密只应用到 ASCII 字母 A-Z 和 a-z 上：","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"function caesar(msg::String, key::Int)\n    io = IOBuffer()\n    for c in msg\n        shift = ('a' <= c <= 'z') ? Int('a') : ('A' <= c <= 'Z') ? Int('A') : 0\n        if shift > 0\n            c = Char((Int(c) - shift + key) % 26 + shift)\n        end\n        print(io, c)\n    end\n    return String(take!(io))\nend","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"就是这样 – 我们实现了一个新的记录器！让我们去兜兜风吧。如果你一直跟着学习到了这儿，并且从开始就复制粘贴代码片段到 Julia REPL 中执行，你应该看到和下面相同的输出：","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"julia> using Logging\n\njulia> cipher_logger = CipherLogger(3); # new logger with 3 as the key\n\njulia> global_logger(cipher_logger); # set the logger as the global logger\n\njulia> @info \"Hello, world!\"\n[Info] Khoor, zruog!\n\njulia> @info \"This is an info message.\"\n[Info] Wklv lv dq lqir phvvdjh.\n\njulia> @warn \"This is a warning.\"\n[Warn] Wklv lv d zduqlqj.\n\njulia> @error \"This is an error message.\"\n[Error] Wklv lv dq huuru phvvdjh.","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"我们也可以确保我们的记录器接收比 Logging.Info 级别低的日志事件（默认的记录器是不支持的）：","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"julia> @debug \"Is this visible?\"\n[Debug] Lv wklv ylvleoh?","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"最后，我们来确保记录器也能捕获日志事件异常。例如，这里我们尝试创建一个带有未定义变量 name 的消息字符串：","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"julia> @info \"hello, $name\"\n[Error] Hafhswlrq zkloh jhqhudwlqj orj uhfrug lq prgxoh Pdlq dw UHSO[17]:1","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"你能破解密文并且理解其意思吗？","category":"page"},{"location":"tutorials/implement-a-new-logger/#cipher-existing","page":"实现一个新的日志记录器","title":"使用已存在的功能构建 CipherLogger","text":"","category":"section"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"如本页开头所示，除非你想要对接一个新类型的记录器槽，通常无需实现自己的记录器。相反，最好是组合现有的日志记录器以实现路由、转换、和过滤日志事件。上面的 CipherLogger 可以像下面这样使用来自 LoggingExtras.jl 包的 TransformerLogger 轻而易举地实现：","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"using Logging, LoggingExtras\n\nencryption_logger = TransformerLogger(SimpleLogger(stderr)) do args\n    message = caesar(args.message, 3)\n    return (; args..., message=message)\nend\n\nglobal_logger(encryption_logger)","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"结果看起来像下面这样：","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"julia> @info \"hello, world\"\n┌ Info: khoor, zruog\n└ @ Main REPL[5]:1","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"使用已存在的 TransformerLogger 的另一个好处是它构造的很好。因此，我们可以用另一层来解密消息：","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"decryption_logger = TransformerLogger(encryption_logger) do args\n    message = caesar(args.message, -3) # to decrypt just negate the key\n    return (; args..., message=message)\nend\n\nglobal_logger(decryption_logger)","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"现在消息再打印到终端之前被加密和解密，因此这种情况下，两个记录器只是相互撤销对方的行为。这是个非常没用的例子，但是可组合性对其他一些事情非常有用！","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"实现一个新的日志记录器","title":"实现一个新的日志记录器","text":"julia> @info \"hello, world\"\n┌ Info: hello, world\n└ @ Main REPL[8]:1","category":"page"}]
}
